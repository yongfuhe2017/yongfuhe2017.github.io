---
category: web
published: false
layout: post
title: 一种单向用户关系的设计
description: 总结我自己是如何处理一种单向用户关系的设计和实现的
---  

## 
## 1. 需求和场景
　　任何设计一开始都不要太高大上了，只要在保证能用、够用的前提下，做到足够简单就行了。这里的场景是用户数短期内不会上万，用户之间只有单向关注的关系，需求是借住用户之间的这些关系，给某用户推荐相关的人物，说白了，就是：

- 二度关系：A关注了B，B关注了C，给A推荐C；
- User-based 推荐：A关注了B，C也关注了B，给A推荐C，给C推荐A；

其他需求是：

- 能少读、写数据库就尽量少，毕竟还会有其他请求要读、写数据库；
- 请求的类型有：
    + [a] 获取A关注的人物列表；
    + [b] 获取关注A的任务列表；
    + [c] 给A进行推荐；
    + [d] 针对某个用户A，更新一条关系信息，包括add、delete；
- 上面三个请求，能多快，就多快，根据伟大的2/8原则，最优先的、实时性最高的是请求a、b、d，然后才是c。

　　ok，其实分析到现在，已经可以发现这个问题并不难了，特别是用户量在短期内不会增长很多。

## 2. 初步设计  
　　首先说说我处理这个问题【其实也是处理大多数问题】的技术栈，后台用Python、Flask和Restful作为语言和web框架，用MongoDB和Redis来作为数据库和缓存，用Celery来管理移步任务。   

　　刚遇到这个问题，我一开始也是想到了特征向量的方法，就像[这里](http://www.zhihu.com/question/21477117)所说的一样，用特征向量来存储所有的用户关系，这样能简单的计算二度关系，而且对用户的关系管理[add/delete]足够简单快捷。然而，用这个方法有两个我目前觉得不够完美的问题：

- [a] 如何存储这个特征向量
- [b] 按照2/8原则来分析，这个特征向量很稀疏，会不会不必要的浪费一些空间

　　针对这两个问题，我们来仔细分析一下。

### 2.1 特征向量的存储问题
　　思考过后，我认为有两个方式：

- 把特征向量序列化后以dict格式存储在mongo中，这样最为直接，但明显不好。首先是因为如此的话每次更新都要写两次数据库，麻烦；更大的原因是每次做计算的时候，都需要先整个把数据load到内存中，然后反序列化成特征向量后计算。
- 同样是把特征向量序列化后以list格式存储在mongo中，只是这个时候换一种序列化方式，以特征向量的每一行作为一个单元序列化，但即使这样，还是会有上面提到的两个问题。

　　坦白地讲，这两个方式都有不少问题，特别是在稀疏矩阵的时候，无谓地浪费了太多空间，下面我们简单的看看到底在空间上浪费是否明显。

### 2.2 稀疏矩阵情况下空间的消耗
　　ok，现在我们假设总共有N个用户，那么特征矩阵应该是N*N大，最简单的用True和False布尔型变量来存储关系的话，关系公式如下图。

![relation.jpg](../images/relation.jpg)

　　那么特征变量占用的内存空间应该就是：size(bool) \* N\^2。这里有一个主要的点，在Python里面，bool型变量并不是简单的一个字节，每个bool型变量都是一个bool类的实例，因为这个实例里还有其他方法和元素，因此比常见的C、C++里的bool变量占用的空间大。如下图可以说明这个情况，这里就按照每个bool型变量占用24字节来计算了，这样的话特征矩阵的大小就是： f(n) = 24\*N\^2/10\^6 (MB)。

![bool_size_in_python.jpg](../images/bool_size_in_python.jpg)

　　简单的画个图就知道这个概念了，如果有100个用户，那么特征变量占用的空间就是0.24MB，如果是1000个用户，就是24MB，5000个客户，就是600MB，10000个客户，就得是2.4GB了。

### 2.3 这样的设计能否满足要求

- 数据库读写：很少，因为从程序启动就要load到内存了，然后应该要定时写到磁盘上备份；
- 请求：
    + [a] 获取A关注的人物列表 - 很快，比如获取用户i关注的用户，直接拿特征矩阵第i行数据；
    + [b] 获取关注A的人物列表 - 很快，比如获取关注用户i的其他用户，直接拿特征矩阵第i列的数据；
    + [c] 给A进行推荐 - 快，直接进行矩阵计算；
    + [d] 针对某个用户A，更新一条关系信息，包括add、delete - 很快；

　　Sounds good?看起来的确是不错啊，没仔细分析之前我都不知道有这么好。不过依然是有点小问题的。因为关系矩阵是在app启动的时候load到内存，一切操作都先操作内存里的特征矩阵，然后定时更新到磁盘上。如果出现服务器或者web server突然down了的情况下，内存特征数据消失，而且没有及时backup到磁盘的话，会有少数数据丢失。but，世界上解决问题的办法总比问题多嘛。针对这个问题，我想到了两个不同的解决方案。

## n. 相关资料
- [如何设计数据结构和算法，计算并存储六度好友关系](http://www.zhihu.com/question/21477117)

## 扫一扫     

![2015-03-19-a-desin-of-user-relation.md](../../images/share/2015-03-19-a-desin-of-user-relation.md.jpg)